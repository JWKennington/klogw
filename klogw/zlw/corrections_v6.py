"""
psd_mismatch_demo_v5.py

Demonstration of first‐ and second‐order timing/phase bias purely from
PSD‐whitening mismatch (no mass mismatch).  We fix (m1=30,m2=30) for both
template and injection, so all inferred offsets come from the fact that we
whiten the template with PSD1 and the data with PSD2.

Each “injection” is generated by choosing (t_true, phi_true), building
    H_sig(f) = H0(f) ⋅ e^{i phi_true} ⋅ e^{−2π i f t_true},
inverse‐FFT that to time domain → x2(t).  We whiten “data” with PSD2 and
“template” with PSD1, do an FFT‐based correlation, then recover t_hat=raw_lag % duration.
The only systematic bias in t_hat is deltat₁ (and a small deltat₂), which we subtract.

Dependencies:
  • numpy
  • matplotlib
  • lalsuite  (lal, lalsimulation)
"""

import numpy as np
import matplotlib.pyplot as plt
import lal
import lalsimulation as lalsim

# =============================================================================
# 1) SETUP: sampling rate, PSD1 vs PSD2, minimum‐phase phi_mp(f)
# =============================================================================

fs = 4096.0           # sampling frequency [Hz]
duration = 20.0       # duration of time series [s]
N = int(fs * duration)
dt = 1.0 / fs
df = 1.0 / duration

# “rfftfreq” returns frequencies [0, 1/T, 2/T, …, fs/2]
freqs = np.fft.rfftfreq(N, d=dt)  # length = N//2 + 1

def psd_aLIGO(f):
    """One‐sided aLIGO Zero‐Det, High‐Power design PSD at frequency f."""
    return lalsim.SimNoisePSDaLIGOZeroDetHighPower(f)

# Build PSD1 (for template whitening) and PSD2 (for data whitening):
PSD1 = np.array([psd_aLIGO(f) for f in freqs])
# perturbation = 1.0 * np.exp(-0.5 * ((freqs - 200.0) / 50.0)**2)
# Uniform perturbations beween -1 and 1
perturbation = np.random.uniform(-1.0, 1.0, size=len(freqs))
PSD2 = PSD1 * (1.0 + 0.5 * perturbation)

# Force any NaN or ≤0 (especially at f=0) → +∞
PSD1[np.isnan(PSD1)] = np.inf
PSD2[np.isnan(PSD2)] = np.inf
PSD1[PSD1 <= 0.0] = np.inf
PSD2[PSD2 <= 0.0] = np.inf

# =============================================================================
# 2) BUILD MINIMUM‐PHASE phi_mp(f) FROM PSD2
# =============================================================================

def compute_minimum_phase_phi(psd, freqs):
    """
    Given a one‐sided PSD array psd[freqs], build the minimum‐phase whitening phase phi_mp(f).
    We set psd2[0] = psd2[1] so that log(psd2) is finite at DC.
    """
    M = len(freqs)
    psd2 = psd.copy()
    psd2[0] = psd2[1]  # avoid −∞ in log at f=0

    # log‐amplitude on positive half:
    logA_pos = -0.5 * np.log(psd2)

    # build a length‐N real vector by Hermitian mirroring:
    logA_full = np.zeros(N, dtype=np.float64)
    logA_full[:M] = logA_pos
    logA_full[M:] = logA_pos[-2:0:-1]

    # real cepstrum = IFFT(logA_full)
    cepstrum = np.fft.ifft(logA_full).real

    # construct minimum‐phase cepstrum:
    minphase_cepstrum = np.zeros_like(cepstrum)
    minphase_cepstrum[0] = cepstrum[0]
    minphase_cepstrum[1 : N // 2] = 2.0 * cepstrum[1 : N // 2]
    if (N % 2) == 0:
        minphase_cepstrum[N // 2] = cepstrum[N // 2]

    # back to complex log‐spectrum
    logMin_full = np.fft.fft(minphase_cepstrum)

    # phi_mp(f) = arg{…} on positive half
    phi_mp = np.angle(logMin_full[:M])
    return phi_mp

phi_mp = compute_minimum_phase_phi(PSD2, freqs)

# Whitening filters:
W1 = 1.0 / np.sqrt(PSD1)                      # linear‐phase (zero‐phase) template whitening
W2 = (1.0 / np.sqrt(PSD2)) * np.exp(1j * phi_mp)  # minimum‐phase data whitening

# =============================================================================
# 3) GENERATE H₀(f) FOR A FIXED (m₁,m₂) = 30+30 M⊙ TaylorF2 INSPIRAL
# =============================================================================

def generate_fd_waveform(f_min, f_max, df, m1, m2, distance_mpc):
    """
    Return (freqs_in, H0) for a non‐spinning TaylorF2 inspiral with masses (m1,m2) [M⊙],
    at distance [Mpc], frequencies from f_min..f_max in steps df.
    H0 is a complex array of length len(freqs_in).
    """
    lal_msun = lal.MSUN_SI
    m1_SI = m1 * lal_msun
    m2_SI = m2 * lal_msun

    freqs_in = np.arange(f_min, f_max + df, df)
    dist_SI = distance_mpc * 1e6 * lal.PC_SI

    spin1x = spin1y = spin1z = 0.0
    spin2x = spin2y = spin2z = 0.0
    eccentricity = 0.0
    meanPerAno = 0.0
    incl = 0.0
    phiRef = 0.0
    longAscNodes = 0.0
    fRef = freqs_in[0]

    Hf_raw = lalsim.SimInspiralFD(
        m1_SI, m2_SI,
        spin1x, spin1y, spin1z,
        spin2x, spin2y, spin2z,
        dist_SI,
        incl, phiRef, longAscNodes,
        eccentricity, meanPerAno,
        df, f_min, f_max, fRef,
        lal.CreateDict(),
        lalsim.TaylorF2
    )

    # If SimInspiralFD returns a list, take the first element (h+):
    if isinstance(Hf_raw, (list, tuple)):
        Hf_series = Hf_raw[0]
    else:
        Hf_series = Hf_raw

    length = Hf_series.data.length
    H0 = np.zeros(length, dtype=np.complex128)
    for idx in range(length):
        comp = Hf_series.data.data[idx]
        H0[idx] = complex(comp.real, comp.imag)

    return freqs_in, H0

# base masses & distance (never changed during injections)
m1_base, m2_base = 30.0, 30.0  # M⊙
distance_base    = 500.0      # Mpc

f_min = freqs[1]
f_max = freqs[-1]
freqs_fd, H0_fd = generate_fd_waveform(f_min, f_max, df, m1_base, m2_base, distance_base)

# Interpolate from freqs_fd → “freqs” grid:
H0 = np.zeros_like(freqs, dtype=complex)
H0[1:] = np.interp(freqs[1:], freqs_fd, H0_fd[1:], left=0.0, right=0.0)
H0[0] = 0.0

# =============================================================================
# 4) ANALYTIC CORRECTION FORMULAS (FIRST & SECOND ORDER)
# =============================================================================

def compute_first_order_corrections(H0, PSD2, phi_mp, freqs):
    """
    deltat₁ = [∫ f · |H0|²/PSD2 · phi_mp df] / [2π ∫ f² · |H0|²/PSD2 df]
    deltaphi₁ = [∫ |H0|²/PSD2 · phi_mp df] / [∫ |H0|²/PSD2 df]
    """
    Wf = (np.abs(H0)**2) / PSD2
    fpos = freqs[1:]
    Wfpos = Wf[1:]
    Phi_pos = phi_mp[1:]

    num_t = np.trapz(fpos * Wfpos * Phi_pos, x=fpos)
    den_t = 2.0 * np.pi * np.trapz(fpos**2 * Wfpos, x=fpos)
    deltat1   = num_t / den_t

    num_phi = np.trapz(Wfpos * Phi_pos, x=fpos)
    den_phi = np.trapz(Wfpos, x=fpos)
    deltaphi1     = num_phi / den_phi

    return deltat1, deltaphi1

def compute_second_order_corrections(H0, PSD2, phi_mp, freqs, deltat1, deltaphi1):
    """
    Leading phi_mp² contributions for deltat₂ and deltaphi₂ (dropping smaller mixed deltat₁ terms):
      deltat₂ ≈ − [∫ f² · W(f) · phi_mp² df] / [ (2π)² ∫ f² · W(f) df ]
      deltaphi₂ ≈ − [∫ W(f) · phi_mp² df] / [ 2 ∫ W(f) df ]
    """
    Wf = (np.abs(H0)**2) / PSD2
    fpos = freqs[1:]
    Wfpos = Wf[1:]
    Phi_pos = phi_mp[1:]

    num2_t = np.trapz((fpos**2) * Wfpos * (Phi_pos**2), x=fpos)
    den2_t = (2.0 * np.pi)**2 * np.trapz((fpos**2) * Wfpos, x=fpos)
    deltat2    = - num2_t / den2_t

    num2_phi = np.trapz(Wfpos * (Phi_pos**2), x=fpos)
    den2_phi = 2.0 * np.trapz(Wfpos, x=fpos)
    deltaphi2     = - num2_phi / den2_phi

    return deltat2, deltaphi2

# compute base‐waveform corrections once:
deltat1_base, deltaphi1_base = compute_first_order_corrections(H0, PSD2, phi_mp, freqs)
deltat2_base, deltaphi2_base = compute_second_order_corrections(
    H0, PSD2, phi_mp, freqs, deltat1_base, deltaphi1_base
)

# =============================================================================
# 5) SINGLE‐EXAMPLE: Plot matched‐filter output + vertical lines
# =============================================================================

# Build “whitened template” time series (no shift = t_true=0, phi_true=0)
H1_base = H0 * W1
h1_base = np.fft.ifft(H1_base, n=N)

# Build “whitened data” time series (also no shift)
X2_base = H0 * W2
x2_base = np.fft.irfft(X2_base, n=N)


def match_filter_time_series(h1, x2):
    """
    Compute the complex matched‐filter time‐series Z(t_c) = ∫ h1(τ) · x2(τ + t_c) dτ,
    keeping its full complex output so that arg(Z) makes sense.

    Steps:
      1) Compute H1_full = FFT[h1(t)] as length‐N complex array.
      2) Compute X2_full = FFT[x2(t)] as length‐N complex array.
      3) corr_full = conj(H1_full) * X2_full  (elementwise, all N bins).
      4) z_unnorm_complex = IFFT[corr_full]   (complex length‐N).
      5) z_t_complex_shifted = fftshift(z_unnorm_complex) so that zero‐lag sits at index N//2.
      6) Build a real “lag” axis:  tc[i] = (i - N//2) * dt,  i=0…N−1.
    Returns:
      • tc: length‐N float array of lags [−T/2, …, +T/2−dt]
      • z_t_complex: length‐N complex array = <h1 | x2>(t_c).
    """
    # 1) Full FFT of the real h1(t) → length‐N complex array
    H1_full = np.fft.fft(h1, n=N)

    # 2) Full FFT of the real x2(t) → length‐N complex array
    X2_full = np.fft.fft(x2, n=N)

    # 3) Multiply conj(H1_full) * X2_full at each of the N frequency bins
    corr_full = np.conj(H1_full) * X2_full

    # 4) IFFT back to time domain, yielding a length‐N complex array
    z_unnorm_complex = np.fft.ifft(corr_full, n=N)

    # 5) Shift so that “zero‐lag” appears at index N//2
    z_t_complex = np.fft.fftshift(z_unnorm_complex)

    # 6) Build the lag axis (in seconds) of length N:
    idx = np.arange(N)                # 0,1,…,N−1
    tc  = (idx - (N//2)) * dt         # e.g. idx=N//2 → tc=0, idx=N//2+1 → +dt, etc.

    return tc, z_t_complex

tc_base, z_t_base = match_filter_time_series(h1_base, x2_base)
idx_peak_base   = np.argmax(np.abs(z_t_base))
raw_lag_base    = tc_base[idx_peak_base]

# Convert raw_lag → physical t_hat in [0, duration):
t_hat_raw_base = raw_lag_base % duration
phi_hat_raw_base = np.angle(z_t_base[idx_peak_base])

# apply corrections:
t_hat_corr1_base  = (t_hat_raw_base - deltat1_base) % duration
t_hat_corr12_base = (t_hat_raw_base - (deltat1_base + deltat2_base)) % duration

phi_hat_corr1_base  = (phi_hat_raw_base - deltaphi1_base) % (2.0 * np.pi)
phi_hat_corr12_base = (phi_hat_raw_base - (deltaphi1_base + deltaphi2_base)) % (2.0 * np.pi)

# Plot single‐example matched‐filter output & vertical lines
plt.figure(figsize=(10, 8))

plt.subplot(3, 1, 1)
plt.loglog(freqs[1:], PSD1[1:], label='PSD1 (lin‐phase)')
plt.loglog(freqs[1:], PSD2[1:], label='PSD2 (min‐phase)')
plt.xlim(10, fs/2)
plt.xlabel('Frequency [Hz]')
plt.ylabel('PSD [1/Hz]')
plt.legend()
plt.title('PSD1 vs. PSD2')

plt.subplot(3, 1, 2)
plt.plot(freqs[1:], phi_mp[1:], 'g-')
plt.xlim(10, fs/2)
plt.xlabel('Frequency [Hz]')
plt.ylabel(r'$\phi_{\rm mp}(f)$')
plt.title('Minimum‐Phase Filter Phase Difference')

plt.subplot(3, 1, 3)
t_arr = np.linspace(0, duration, N, endpoint=False)
center = N // 2
window = 256
plt.plot(
    t_arr[center-window : center+window],
    h1_base[center-window : center+window], 'b-',
    label='Whitened Template (t_true=0)'
)
plt.plot(
    t_arr[center-window : center+window],
    x2_base[center-window : center+window], 'r-',
    label='Whitened Data       (t_true=0)', alpha=0.7
)
plt.xlabel('Time [s]')
plt.ylabel('Whitened Strain')
plt.title('Zoomed Whitened Template vs. Data')
plt.legend()
plt.tight_layout()
plt.show()

plt.figure(figsize=(6, 4))
plt.plot(tc_base, np.abs(z_t_base), 'k-')
plt.axvline(t_hat_raw_base,   color='r', linestyle='--',
            label=f'raw $t_{{hat}}$ = {t_hat_raw_base:.4f} s')
plt.axvline(t_hat_corr1_base, color='b', linestyle='-.',
            label=f'1st‐order corr = {t_hat_corr1_base:.4f} s')
plt.axvline(t_hat_corr12_base,color='m', linestyle=':',
            label=f'1+2nd‐order corr = {t_hat_corr12_base:.4f} s')
plt.xlabel('$t_c$ [s]')
plt.ylabel(r'$|Z(t_c)|$')
plt.title('Matched‐Filter Output: Single Example')
plt.legend()
plt.tight_layout()
plt.show()

# =============================================================================
# 6) MULTIPLE INJECTIONS: vary only (t_true, phi_true); keep (m₁,m₂)=30+30 fixed
# =============================================================================

n_injections = 500

t_true_list        = []
t_hat_raw_list     = []
t_hat_corr1_list   = []
t_hat_corr12_list  = []
phi_true_list      = []
phi_hat_raw_list   = []
phi_hat_corr1_list = []
phi_hat_corr12_list= []

for i in range(n_injections):
    # (1) Choose random coalescence time & phase
    t_true   = np.random.uniform(0.3, duration - 0.3)
    phi_true = np.random.uniform(0.0, 2.0 * np.pi)

    # (2) Build FD injection (one‐sided):
    #     Hsig_i(f) = H0(f) ⋅ e^{i φ_true} ⋅ e^{-2π i f t_true}
    phase_shift = np.exp(-2j * np.pi * freqs * t_true)
    Hsig_i      = H0 * np.exp(1j * phi_true) * phase_shift

    # ─────────────────────────────────────────────────────────────────────────
    # REAL branch: whiten with PSD2 → IFFT to get x2_i(t), *do NOT roll*
    # ─────────────────────────────────────────────────────────────────────────
    X2_i = Hsig_i * W2
    x2_i = np.fft.irfft(X2_i, n=N)  # coalescence already sits at t_true

    # (4d) Directly matched‐filter against the centered template:
    tc_i, z_t_i_complex = match_filter_time_series(
        h1_base,
        x2_i
    )

    idx_peak_i = np.argmax(np.abs(z_t_i_complex))
    raw_lag_i  = tc_i[idx_peak_i]            # ≈ +Δt₁  (because t_true was built into Hsig_i)
    t_hat_i    = raw_lag_i % duration

    # (4f) Extract complex z_peak, then its argument
    z_peak_i  = z_t_i_complex[idx_peak_i]
    phi_hat_i = np.angle(z_peak_i)  # now *nonzero*, tracks phi_true + Δφ₁

    # ─────────────────────────────────────────────────────────────────────────
    # CONTROL branch: whiten with PSD1 → IFFT, *do NOT roll*
    # ─────────────────────────────────────────────────────────────────────────
    X2_i_ctrl    = Hsig_i * W1
    x2_ctrl_raw  = np.fft.irfft(X2_i_ctrl, n=N)

    tc_i_ctrl, z_t_i_ctrl_complex = match_filter_time_series(
        h1_base,
        x2_ctrl_raw
    )
    idx_peak_i_ctrl    = np.argmax(np.abs(z_t_i_ctrl_complex))
    raw_lag_i_ctrl     = tc_i_ctrl[idx_peak_i_ctrl]
    t_hat_i_ctrl       = raw_lag_i_ctrl % duration  # should be ≈ 0

    z_peak_i_ctrl     = z_t_i_ctrl_complex[idx_peak_i_ctrl]
    phi_hat_i_ctrl    = np.angle(z_peak_i_ctrl)     # should be ≈ 0

    # (Optional) Print first few to confirm:
    if i < 3:
        # First print the true and hat and control values
        print(f"Injection {i}:")
        print(f"  t_true = {t_true:.4f} s,  phi_true = {phi_true:.4f} rad")
        print(f"  raw t_hat = {t_hat_i:.4f} s,  raw phi_hat = {phi_hat_i:.4f} rad")
        print(f"  raw t_hat_ctrl = {t_hat_i_ctrl:.4f} s,  raw phi_hat_ctrl = {phi_hat_i_ctrl:.4f} rad")
        print(f"  deltat₁ = {deltat1_base:.4f} s,  deltaphi₁ = {deltaphi1_base:.4f} rad")
        print(f"  deltat₂ = {deltat2_base:.4f} s,  deltaphi₂ = {deltaphi2_base:.4f} rad")
        print(f"  raw lag = {raw_lag_i:.4f} s,  ctrl lag = {raw_lag_i_ctrl:.4f} s")


        plt.figure(figsize=(8, 4))
        plt.plot(tc_i, np.abs(z_t_i_complex), "k-", label="Matched Filter Output")
        plt.axvline(
            raw_lag_i,
            color="red",
            linestyle="--",
            label=f"raw $t_{{lag}}$ = {raw_lag_i:.4f} s",
        )
        plt.axvline(
            raw_lag_i_ctrl,
            color="blue",
            linestyle="-.",
            label=f"ctrl $t_{{lag}}$ = {raw_lag_i_ctrl:.4f} s",
        )
        plt.xlabel("$t_c$ [s]")
        plt.ylabel(r"$|Z(t_c)|$")

        # Center your zoom on raw_lag_i (which always lies in [-10,+10]):
        plt.xlim(raw_lag_i - 0.1, raw_lag_i + 0.1)

        plt.title(f"Matched Filter Output: Injection {i}")
        plt.legend()
        plt.tight_layout()
        plt.show()

    # (7) Apply analytic corrections Δt₁, Δφ₁, Δt₂, Δφ₂
    t_hat_corr1_i   = (t_hat_i - deltat1_base)                 % duration
    t_hat_corr12_i  = (t_hat_i - (deltat1_base + deltat2_base)) % duration

    phi_hat_corr1_i  = (phi_hat_i - deltaphi1_base)                 % (2*np.pi)
    phi_hat_corr12_i = (phi_hat_i - (deltaphi1_base + deltaphi2_base)) % (2*np.pi)

    # (8) Store results
    t_true_list.append(t_true)
    t_hat_raw_list.append(t_hat_i)
    t_hat_corr1_list.append(t_hat_corr1_i)
    t_hat_corr12_list.append(t_hat_corr12_i)

    phi_true_list.append(phi_true)
    phi_hat_raw_list.append(phi_hat_i)
    phi_hat_corr1_list.append(phi_hat_corr1_i)
    phi_hat_corr12_list.append(phi_hat_corr12_i)


# convert to arrays:
t_true_arr       = np.array(t_true_list)
t_hat_raw_arr    = np.array(t_hat_raw_list)
t_hat_corr1_arr  = np.array(t_hat_corr1_list)
t_hat_corr12_arr = np.array(t_hat_corr12_list)

phi_true_arr       = np.array(phi_true_list)
phi_hat_raw_arr    = np.array(phi_hat_raw_list)
phi_hat_corr1_arr  = np.array(phi_hat_corr1_list)
phi_hat_corr12_arr = np.array(phi_hat_corr12_list)

# =============================================================================
# 7) PLOT SCATTER: Raw vs. Corrected (Time & Phase)
# =============================================================================

plt.figure(figsize=(12, 5))

plt.subplot(1, 2, 1)
plt.scatter(t_true_arr,   t_hat_raw_arr,    color='red',   alpha=0.5, label='Raw  $t_{hat}$')
plt.scatter(t_true_arr,   t_hat_corr1_arr,  color='blue',  alpha=0.5, label='1st‐order corr')
plt.scatter(t_true_arr,   t_hat_corr12_arr, color='magenta',alpha=0.5, label='1+2nd‐order corr')
plt.plot([0, duration], [0, duration], 'k--', label='Ideal')
plt.xlabel('True $t_c$ [s]')
plt.ylabel('Estimated $t_c$ [s]')
plt.title('Coalescence Time: Raw vs. Corrections')
plt.legend()
plt.xlim(0, duration)
plt.ylim(0, duration)

plt.subplot(1, 2, 2)
plt.scatter(phi_true_arr,    phi_hat_raw_arr,    color='red',   alpha=0.5, label='Raw  $phi_{hat}$')
plt.scatter(phi_true_arr,    phi_hat_corr1_arr,  color='blue',  alpha=0.5, label='1st‐order corr')
plt.scatter(phi_true_arr,    phi_hat_corr12_arr, color='magenta',alpha=0.5, label='1+2nd‐order corr')
plt.plot([0, 2*np.pi], [0, 2*np.pi], 'k--', label='Ideal')
plt.xlabel('True $phi_c$ [rad]')
plt.ylabel('Estimated $phi_c$ [rad]')
plt.title('Coalescence Phase: Raw vs. Corrections')
plt.legend()
plt.xlim(0, 2*np.pi)
plt.ylim(0, 2*np.pi)

plt.tight_layout()
plt.show()

# Timing arrays
t_true_arr       = np.array(t_true_list)          # shape = (N_inj,)
t_hat_raw_arr    = np.array(t_hat_raw_list)
t_hat_corr1_arr  = np.array(t_hat_corr1_list)
t_hat_corr12_arr = np.array(t_hat_corr12_list)

# Phase arrays
phi_true_arr       = np.array(phi_true_list)
phi_hat_raw_arr    = np.array(phi_hat_raw_list)
phi_hat_corr1_arr  = np.array(phi_hat_corr1_list)
phi_hat_corr12_arr = np.array(phi_hat_corr12_list)

# Sanity-check lengths
assert (
    t_true_arr.shape == t_hat_raw_arr.shape
    == t_hat_corr1_arr.shape
    == t_hat_corr12_arr.shape
), "Timing arrays must all have the same length"
assert (
    phi_true_arr.shape == phi_hat_raw_arr.shape
    == phi_hat_corr1_arr.shape
    == phi_hat_corr12_arr.shape
), "Phase arrays must all have the same length"


# ─────────────────────────────────────────────────────────────────────────────
# (B) Compute timing residuals, wrapped into [-T/2, +T/2)
# ─────────────────────────────────────────────────────────────────────────────

T = duration  # total duration in seconds

# Raw residuals: delta_raw = t_hat_raw - t_true, wrapped into [-T/2, +T/2)
delta_raw = t_hat_raw_arr - t_true_arr
raw_residuals = (delta_raw + 1.5 * T) % T - 0.5 * T

# First-order corrected residuals: delta_corr1 = t_hat_corr1 - t_true
delta_corr1 = t_hat_corr1_arr - t_true_arr
corr1_residuals = (delta_corr1 + 1.5 * T) % T - 0.5 * T

# First+Second-order corrected: delta_corr12 = t_hat_corr12 - t_true
delta_corr12 = t_hat_corr12_arr - t_true_arr
corr12_residuals = (delta_corr12 + 1.5 * T) % T - 0.5 * T


# ─────────────────────────────────────────────────────────────────────────────
# (C) Compute phase residuals, wrapped into [-pi, +pi)
# ─────────────────────────────────────────────────────────────────────────────

phi_diff_raw    = np.angle(np.exp(1j * phi_hat_raw_arr)   / np.exp(1j * phi_true_arr))
phi_diff_corr1  = np.angle(np.exp(1j * phi_hat_corr1_arr) / np.exp(1j * phi_true_arr))
phi_diff_corr12 = np.angle(np.exp(1j * phi_hat_corr12_arr)/ np.exp(1j * phi_true_arr))


# ─────────────────────────────────────────────────────────────────────────────
# (D) Determine dynamic x-axis limits based on the data
# ─────────────────────────────────────────────────────────────────────────────

# Timing: find the maximum absolute residual among all three sets
max_t = np.max(np.abs(
    np.concatenate([raw_residuals, corr1_residuals, corr12_residuals])
))
# Add a small margin, e.g. 10% larger
t_lim = max_t * 1.1

# Phase: find the maximum absolute phase residual
max_phi = np.max(np.abs(
    np.concatenate([phi_diff_raw, phi_diff_corr1, phi_diff_corr12])
))
# Add 10% margin
phi_lim = max_phi * 1.1


# ─────────────────────────────────────────────────────────────────────────────
# (E) Plot overlaid histograms for timing and phase residuals
# ─────────────────────────────────────────────────────────────────────────────

plt.figure(figsize=(12, 5))

# E1) Timing histogram (left panel)
plt.subplot(1, 2, 1)

# Create 100 bins spanning [-t_lim, +t_lim]
bins_time = np.linspace(-t_lim, +t_lim, 100)

plt.hist(raw_residuals,    bins=bins_time, color='red',     alpha=0.6, label='Raw')
plt.hist(corr1_residuals,  bins=bins_time, color='blue',    alpha=0.6, label='First-order correction')
plt.hist(corr12_residuals, bins=bins_time, color='magenta', alpha=0.6, label='First+Second-order correction')

plt.axvline(0.0, color='black', linestyle='--', linewidth=1)
plt.xlabel('Timing residual (t_hat - t_true) [s]')
plt.ylabel('Number of injections')
plt.title('Timing residuals: raw vs corrected')
plt.legend()
plt.xlim(-t_lim, +t_lim)


# E2) Phase histogram (right panel)
plt.subplot(1, 2, 2)

# Create 100 bins spanning [-phi_lim, +phi_lim]
bins_phase = np.linspace(-phi_lim, +phi_lim, 100)

plt.hist(phi_diff_raw,    bins=bins_phase, color='orange', alpha=0.6, label='Raw')
plt.hist(phi_diff_corr1,  bins=bins_phase, color='green',  alpha=0.6, label='First-order correction')
plt.hist(phi_diff_corr12, bins=bins_phase, color='purple', alpha=0.6, label='First+Second-order correction')

plt.axvline(0.0, color='black', linestyle='--', linewidth=1)
plt.xlabel('Phase residual (phi_hat - phi_true) [rad]')
plt.ylabel('Number of injections')
plt.title('Phase residuals: raw vs corrected')
plt.legend()
plt.xlim(-phi_lim, +phi_lim)

plt.tight_layout()
plt.show()
