#!/usr/bin/env python
"""
psd_mismatch_demo_v5.py

Demonstration of first‐ and second‐order timing/phase bias purely from
PSD‐whitening mismatch (no mass mismatch).  We fix (m1=30,m2=30) for both
template and injection, so all inferred offsets come from the fact that we
whiten the template with PSD1 and the data with PSD2.

Each “injection” is generated by choosing (t_true, phi_true), building
    H_sig(f) = H0(f) ⋅ e^{i phi_true} ⋅ e^{−2π i f t_true},
inverse‐FFT that to time domain → x2(t).  We whiten “data” with PSD2 and
“template” with PSD1, do an FFT‐based correlation, then recover t_hat=raw_lag % duration.
The only systematic bias in t_hat is deltat₁ (and a small deltat₂), which we subtract.

Dependencies:
  • numpy
  • matplotlib
  • lalsuite  (lal, lalsimulation)
"""

import numpy as np
import matplotlib.pyplot as plt
import lal
import lalsimulation as lalsim

from klogw.zlw.corrections_example import perturbation

# =============================================================================
# 1) SETUP: sampling rate, PSD1 vs PSD2, minimum‐phase phi_mp(f)
# =============================================================================

fs = 4096.0           # sampling frequency [Hz]
duration = 20.0       # duration of time series [s]
N = int(fs * duration)
dt = 1.0 / fs
df = 1.0 / duration

# “rfftfreq” returns frequencies [0, 1/T, 2/T, …, fs/2]
freqs = np.fft.rfftfreq(N, d=dt)  # length = N//2 + 1

def psd_aLIGO(f):
    """One‐sided aLIGO Zero‐Det, High‐Power design PSD at frequency f."""
    return lalsim.SimNoisePSDaLIGOZeroDetHighPower(f)

# Build PSD1 (for template whitening) and PSD2 (for data whitening):
PSD1 = np.array([psd_aLIGO(f) for f in freqs])
# perturbation = 0.1 * np.exp(-0.5 * ((freqs - 150.0) / 50.0)**2)
# Uniform perturbations beween -1 and 1
perturbation = np.random.uniform(-1.0, 1.0, size=len(freqs))
PSD2 = PSD1 * (1.0 + 1.0 * perturbation)

# Force any NaN or ≤0 (especially at f=0) → +∞
PSD1[np.isnan(PSD1)] = np.inf
PSD2[np.isnan(PSD2)] = np.inf
PSD1[PSD1 <= 0.0] = np.inf
PSD2[PSD2 <= 0.0] = np.inf

# =============================================================================
# 2) BUILD MINIMUM‐PHASE phi_mp(f) FROM PSD2
# =============================================================================

def compute_minimum_phase_phi(psd, freqs):
    """
    Given a one‐sided PSD array psd[freqs], build the minimum‐phase whitening phase phi_mp(f).
    We set psd2[0] = psd2[1] so that log(psd2) is finite at DC.
    """
    M = len(freqs)
    psd2 = psd.copy()
    psd2[0] = psd2[1]  # avoid −∞ in log at f=0

    # log‐amplitude on positive half:
    logA_pos = -0.5 * np.log(psd2)

    # build a length‐N real vector by Hermitian mirroring:
    logA_full = np.zeros(N, dtype=np.float64)
    logA_full[:M] = logA_pos
    logA_full[M:] = logA_pos[-2:0:-1]

    # real cepstrum = IFFT(logA_full)
    cepstrum = np.fft.ifft(logA_full).real

    # construct minimum‐phase cepstrum:
    minphase_cepstrum = np.zeros_like(cepstrum)
    minphase_cepstrum[0] = cepstrum[0]
    minphase_cepstrum[1 : N // 2] = 2.0 * cepstrum[1 : N // 2]
    if (N % 2) == 0:
        minphase_cepstrum[N // 2] = cepstrum[N // 2]

    # back to complex log‐spectrum
    logMin_full = np.fft.fft(minphase_cepstrum)

    # phi_mp(f) = arg{…} on positive half
    phi_mp = np.angle(logMin_full[:M])
    return phi_mp

phi_mp = compute_minimum_phase_phi(PSD2, freqs)

# Whitening filters:
W1 = 1.0 / np.sqrt(PSD1)                      # linear‐phase (zero‐phase) template whitening
W2 = (1.0 / np.sqrt(PSD2)) * np.exp(1j * phi_mp)  # minimum‐phase data whitening

# =============================================================================
# 3) GENERATE H₀(f) FOR A FIXED (m₁,m₂) = 30+30 M⊙ TaylorF2 INSPIRAL
# =============================================================================

def generate_fd_waveform(f_min, f_max, df, m1, m2, distance_mpc):
    """
    Return (freqs_in, H0) for a non‐spinning TaylorF2 inspiral with masses (m1,m2) [M⊙],
    at distance [Mpc], frequencies from f_min..f_max in steps df.
    H0 is a complex array of length len(freqs_in).
    """
    lal_msun = lal.MSUN_SI
    m1_SI = m1 * lal_msun
    m2_SI = m2 * lal_msun

    freqs_in = np.arange(f_min, f_max + df, df)
    dist_SI = distance_mpc * 1e6 * lal.PC_SI

    spin1x = spin1y = spin1z = 0.0
    spin2x = spin2y = spin2z = 0.0
    eccentricity = 0.0
    meanPerAno = 0.0
    incl = 0.0
    phiRef = 0.0
    longAscNodes = 0.0
    fRef = freqs_in[0]

    Hf_raw = lalsim.SimInspiralFD(
        m1_SI, m2_SI,
        spin1x, spin1y, spin1z,
        spin2x, spin2y, spin2z,
        dist_SI,
        incl, phiRef, longAscNodes,
        eccentricity, meanPerAno,
        df, f_min, f_max, fRef,
        lal.CreateDict(),
        lalsim.TaylorF2
    )

    # If SimInspiralFD returns a list, take the first element (h+):
    if isinstance(Hf_raw, (list, tuple)):
        Hf_series = Hf_raw[0]
    else:
        Hf_series = Hf_raw

    length = Hf_series.data.length
    H0 = np.zeros(length, dtype=np.complex128)
    for idx in range(length):
        comp = Hf_series.data.data[idx]
        H0[idx] = complex(comp.real, comp.imag)

    return freqs_in, H0

# base masses & distance (never changed during injections)
m1_base, m2_base = 30.0, 30.0  # M⊙
distance_base    = 500.0      # Mpc

f_min = freqs[1]
f_max = freqs[-1]
freqs_fd, H0_fd = generate_fd_waveform(f_min, f_max, df, m1_base, m2_base, distance_base)

# Interpolate from freqs_fd → “freqs” grid:
H0 = np.zeros_like(freqs, dtype=complex)
H0[1:] = np.interp(freqs[1:], freqs_fd, H0_fd[1:], left=0.0, right=0.0)
H0[0] = 0.0

# =============================================================================
# 4) ANALYTIC CORRECTION FORMULAS (FIRST & SECOND ORDER)
# =============================================================================

def compute_first_order_corrections(H0, PSD2, phi_mp, freqs):
    """
    deltat₁ = [∫ f · |H0|²/PSD2 · phi_mp df] / [2π ∫ f² · |H0|²/PSD2 df]
    deltaphi₁ = [∫ |H0|²/PSD2 · phi_mp df] / [∫ |H0|²/PSD2 df]
    """
    Wf = (np.abs(H0)**2) / PSD2
    fpos = freqs[1:]
    Wfpos = Wf[1:]
    Phi_pos = phi_mp[1:]

    num_t = np.trapz(fpos * Wfpos * Phi_pos, x=fpos)
    den_t = 2.0 * np.pi * np.trapz(fpos**2 * Wfpos, x=fpos)
    deltat1   = num_t / den_t

    num_phi = np.trapz(Wfpos * Phi_pos, x=fpos)
    den_phi = np.trapz(Wfpos, x=fpos)
    deltaphi1     = num_phi / den_phi

    return deltat1, deltaphi1

def compute_second_order_corrections(H0, PSD2, phi_mp, freqs, deltat1, deltaphi1):
    """
    Leading phi_mp² contributions for deltat₂ and deltaphi₂ (dropping smaller mixed deltat₁ terms):
      deltat₂ ≈ − [∫ f² · W(f) · phi_mp² df] / [ (2π)² ∫ f² · W(f) df ]
      deltaphi₂ ≈ − [∫ W(f) · phi_mp² df] / [ 2 ∫ W(f) df ]
    """
    Wf = (np.abs(H0)**2) / PSD2
    fpos = freqs[1:]
    Wfpos = Wf[1:]
    Phi_pos = phi_mp[1:]

    num2_t = np.trapz((fpos**2) * Wfpos * (Phi_pos**2), x=fpos)
    den2_t = (2.0 * np.pi)**2 * np.trapz((fpos**2) * Wfpos, x=fpos)
    deltat2    = - num2_t / den2_t

    num2_phi = np.trapz(Wfpos * (Phi_pos**2), x=fpos)
    den2_phi = 2.0 * np.trapz(Wfpos, x=fpos)
    deltaphi2     = - num2_phi / den2_phi

    return deltat2, deltaphi2

# compute base‐waveform corrections once:
deltat1_base, deltaphi1_base = compute_first_order_corrections(H0, PSD2, phi_mp, freqs)
deltat2_base, deltaphi2_base = compute_second_order_corrections(
    H0, PSD2, phi_mp, freqs, deltat1_base, deltaphi1_base
)

# =============================================================================
# 5) SINGLE‐EXAMPLE: Plot matched‐filter output + vertical lines
# =============================================================================

# Build “whitened template” time series (no shift = t_true=0, phi_true=0)
H1_base = H0 * W1
h1_base = np.fft.irfft(H1_base, n=N)
# <<<--- IMPORTANT: roll so that index 0 → index N//2
h1_base_centered = np.roll(h1_base, N // 2)

# Build “whitened data” time series (also no shift)
X2_base = H0 * W2
x2_base = np.fft.irfft(X2_base, n=N)


def match_filter_time_series(h1, x2):
    """
    Compute Z(t_c) = ∫ h1(τ) · x2(τ + t_c) dτ via FFT convolution,
    then do an fftshift so that “zero‐lag” is at array index N//2.

    Returns:
      • tc:  length‐N array of time lags in seconds, from  −(N/2)*dt  up to  +((N/2)−1)*dt
      • z_t: length‐N array of |Z(t_c)| (after fftshift), so that z_t[N//2] = Z(0).
    """
    # 1) FFT of the template:
    H1_t = np.fft.rfft(h1, n=N)

    # 2) FFT of the data:
    X2_t = np.fft.rfft(x2, n=N)

    # 3) Multiply conj(H1) * X2:
    corr_f = np.conj(H1_t) * X2_t

    # 4) IFFT → real cross‐correlation array of length N:
    z_unnorm = np.fft.irfft(corr_f, n=N)

    # 5) fftshift → move “lag=0” to the midpoint:
    z_t = np.fft.fftshift(z_unnorm)

    # 6) Build the time-lag axis:  index N//2 → lag = 0; index N//2+1 → +dt; etc.
    idx = np.arange(N)              # 0,1,2,...,N−1
    tc  = (idx - (N//2)) * dt       # e.g. idx=N//2 → tc=0; idx=N//2+1 → tc=+dt; idx=N//2-1→tc=−dt

    return tc, z_t

tc_base, z_t_base = match_filter_time_series(h1_base, x2_base)
idx_peak_base   = np.argmax(np.abs(z_t_base))
raw_lag_base    = tc_base[idx_peak_base]

# Convert raw_lag → physical t_hat in [0, duration):
t_hat_raw_base = raw_lag_base % duration
phi_hat_raw_base = np.angle(z_t_base[idx_peak_base])

# apply corrections:
t_hat_corr1_base  = (t_hat_raw_base - deltat1_base) % duration
t_hat_corr12_base = (t_hat_raw_base - (deltat1_base + deltat2_base)) % duration

phi_hat_corr1_base  = (phi_hat_raw_base - deltaphi1_base) % (2.0 * np.pi)
phi_hat_corr12_base = (phi_hat_raw_base - (deltaphi1_base + deltaphi2_base)) % (2.0 * np.pi)

# Plot single‐example matched‐filter output & vertical lines
plt.figure(figsize=(10, 8))

plt.subplot(3, 1, 1)
plt.loglog(freqs[1:], PSD1[1:], label='PSD1 (lin‐phase)')
plt.loglog(freqs[1:], PSD2[1:], label='PSD2 (min‐phase)')
plt.xlim(10, fs/2)
plt.xlabel('Frequency [Hz]')
plt.ylabel('PSD [1/Hz]')
plt.legend()
plt.title('PSD1 vs. PSD2')

plt.subplot(3, 1, 2)
plt.plot(freqs[1:], phi_mp[1:], 'g-')
plt.xlim(10, fs/2)
plt.xlabel('Frequency [Hz]')
plt.ylabel(r'$\phi_{\rm mp}(f)$')
plt.title('Minimum‐Phase Filter Phase Difference')

plt.subplot(3, 1, 3)
t_arr = np.linspace(0, duration, N, endpoint=False)
center = N // 2
window = 256
plt.plot(
    t_arr[center-window : center+window],
    h1_base[center-window : center+window], 'b-',
    label='Whitened Template (t_true=0)'
)
plt.plot(
    t_arr[center-window : center+window],
    x2_base[center-window : center+window], 'r-',
    label='Whitened Data       (t_true=0)', alpha=0.7
)
plt.xlabel('Time [s]')
plt.ylabel('Whitened Strain')
plt.title('Zoomed Whitened Template vs. Data')
plt.legend()
plt.tight_layout()
plt.show()

plt.figure(figsize=(6, 4))
plt.plot(tc_base, np.abs(z_t_base), 'k-')
plt.axvline(t_hat_raw_base,   color='r', linestyle='--',
            label=f'raw $t_{{hat}}$ = {t_hat_raw_base:.4f} s')
plt.axvline(t_hat_corr1_base, color='b', linestyle='-.',
            label=f'1st‐order corr = {t_hat_corr1_base:.4f} s')
plt.axvline(t_hat_corr12_base,color='m', linestyle=':',
            label=f'1+2nd‐order corr = {t_hat_corr12_base:.4f} s')
plt.xlabel('$t_c$ [s]')
plt.ylabel(r'$|Z(t_c)|$')
plt.title('Matched‐Filter Output: Single Example')
plt.legend()
plt.tight_layout()
plt.show()

# =============================================================================
# 6) MULTIPLE INJECTIONS: vary only (t_true, phi_true); keep (m₁,m₂)=30+30 fixed
# =============================================================================

n_injections = 50
t_true_list       = []
t_hat_raw_list    = []
t_hat_corr1_list  = []
t_hat_corr12_list = []
phi_true_list       = []
phi_hat_raw_list    = []
phi_hat_corr1_list  = []
phi_hat_corr12_list = []

for i in range(n_injections):
    # pick random coalescence time & phase
    t_true = np.random.uniform(0.3, duration - 0.3)
    phi_true = np.random.uniform(0.0, 2.0 * np.pi)

    # Template is STILL H0(f) for (30+30)M⊙:
    H0_i = H0.copy()

    # The bias deltat₁, deltaphi₁, deltat₂, deltaphi₂ are the same as “base”
    Dt1_i, Dphi1_i = deltat1_base, deltaphi1_base
    Dt2_i, Dphi2_i = deltat2_base, deltaphi2_base

    h1_i_centered = h1_base_centered
    # build time‐domain whitened template:
    H1_i = H0_i * W1
    h1_i = np.fft.irfft(H1_i, n=N)

    # build FD injection: H_sig(f) = H0_i(f) · e^{i phi_true} · e^{−2π i f t_true}
    phase_shift = np.exp(-2j * np.pi * freqs * t_true)
    Hsig_i = H0_i * np.exp(1j * phi_true) * phase_shift

    # 1) Whitened, frequency‐domain data:
    X2_i = Hsig_i * W2

    # 2) Inverse FFT → a real array of length N.
    x2_i = np.fft.irfft(X2_i, n=N)

    # 3) “Unwrap” the coalescence from index round(t_true/dt) → index 0:
    idx_shift = int(np.round(t_true / dt))
    x2_unwrapped = np.roll(x2_i, -idx_shift)

    # 4) “Center” the coalescence (index 0 → index N//2):
    x2_i_centered = np.roll(x2_unwrapped, N // 2)

    # 5) Matched filter using the pre‐centered template and this centered data:
    tc_i, z_t_i = match_filter_time_series(h1_base_centered, x2_i_centered)

    # matched filter:
    tc_i, z_t_i = match_filter_time_series(h1_i, x2_i)
    idx_peak_i  = np.argmax(np.abs(z_t_i))
    raw_lag_i   = tc_i[idx_peak_i]

    # CONTROL by whitening data with W1
    x2_i_ctrl = np.fft.irfft(Hsig_i * W1, n=N)
    x2_unwrapped_ctrl = np.roll(x2_i_ctrl, -idx_shift)
    x2_i_centered_ctrl = np.roll(x2_unwrapped_ctrl, N // 2)
    tc_i_ctrl, z_t_i_ctrl = match_filter_time_series(h1_base_centered, x2_i_centered_ctrl)
    idx_peak_i_ctrl = np.argmax(np.abs(z_t_i_ctrl))
    raw_lag_i_ctrl = tc_i_ctrl[idx_peak_i_ctrl]


    # Plot first few injections:
    if i < 5:
        plt.figure(figsize=(10, 6))
        plt.plot(tc_i, np.abs(z_t_i), 'k-')
        plt.axvline(raw_lag_i,   color='r', linestyle='--',
                    label=f'raw $t_{{hat}}$ = {raw_lag_i:.4f} s')
        plt.axvline(raw_lag_i - Dt1_i, color='b', linestyle='-.',
                    label=f'1st‐order corr = {(raw_lag_i - Dt1_i) % duration:.4f} s')
        plt.axvline(raw_lag_i - (Dt1_i + Dt2_i), color='m', linestyle=':',
                    label=f'1+2nd‐order corr = {(raw_lag_i - (Dt1_i + Dt2_i)) % duration:.4f} s')
        plt.xlabel('$t_c$ [s]')
        plt.ylabel(r'$|Z(t_c)|$')
        # Zoom in near the peak:
        plt.xlim(raw_lag_i - 1.0, raw_lag_i + 1.0)

        plt.title(f'Matched‐Filter Output: Injection {i+1}')
        plt.legend()
        plt.tight_layout()
        plt.show()

    # convert to physical t_hat:
    t_hat = raw_lag_i % duration
    phi_hat = np.angle(z_t_i[idx_peak_i])

    # apply corrections:
    t_hat_corr1  = (t_hat - Dt1_i)         % duration
    t_hat_corr12 = (t_hat - (Dt1_i + Dt2_i)) % duration

    phi_hat_corr1  = (phi_hat - Dphi1_i)         % (2.0 * np.pi)
    phi_hat_corr12 = (phi_hat - (Dphi1_i + Dphi2_i)) % (2.0 * np.pi)

    # store:
    t_true_list.append(t_true)
    t_hat_raw_list.append(t_hat)
    t_hat_corr1_list.append(t_hat_corr1)
    t_hat_corr12_list.append(t_hat_corr12)

    phi_true_list.append(phi_true)
    phi_hat_raw_list.append(phi_hat)
    phi_hat_corr1_list.append(phi_hat_corr1)
    phi_hat_corr12_list.append(phi_hat_corr12)

# convert to arrays:
t_true_arr       = np.array(t_true_list)
t_hat_raw_arr    = np.array(t_hat_raw_list)
t_hat_corr1_arr  = np.array(t_hat_corr1_list)
t_hat_corr12_arr = np.array(t_hat_corr12_list)

phi_true_arr       = np.array(phi_true_list)
phi_hat_raw_arr    = np.array(phi_hat_raw_list)
phi_hat_corr1_arr  = np.array(phi_hat_corr1_list)
phi_hat_corr12_arr = np.array(phi_hat_corr12_list)

# =============================================================================
# 7) PLOT SCATTER: Raw vs. Corrected (Time & Phase)
# =============================================================================

plt.figure(figsize=(12, 5))

plt.subplot(1, 2, 1)
plt.scatter(t_true_arr,   t_hat_raw_arr,    color='red',   alpha=0.5, label='Raw  $t_{hat}$')
plt.scatter(t_true_arr,   t_hat_corr1_arr,  color='blue',  alpha=0.5, label='1st‐order corr')
plt.scatter(t_true_arr,   t_hat_corr12_arr, color='magenta',alpha=0.5, label='1+2nd‐order corr')
plt.plot([0, duration], [0, duration], 'k--', label='Ideal')
plt.xlabel('True $t_c$ [s]')
plt.ylabel('Estimated $t_c$ [s]')
plt.title('Coalescence Time: Raw vs. Corrections')
plt.legend()
plt.xlim(0, duration)
plt.ylim(0, duration)

plt.subplot(1, 2, 2)
plt.scatter(phi_true_arr,    phi_hat_raw_arr,    color='red',   alpha=0.5, label='Raw  $phi_{hat}$')
plt.scatter(phi_true_arr,    phi_hat_corr1_arr,  color='blue',  alpha=0.5, label='1st‐order corr')
plt.scatter(phi_true_arr,    phi_hat_corr12_arr, color='magenta',alpha=0.5, label='1+2nd‐order corr')
plt.plot([0, 2*np.pi], [0, 2*np.pi], 'k--', label='Ideal')
plt.xlabel('True $phi_c$ [rad]')
plt.ylabel('Estimated $phi_c$ [rad]')
plt.title('Coalescence Phase: Raw vs. Corrections')
plt.legend()
plt.xlim(0, 2*np.pi)
plt.ylim(0, 2*np.pi)

plt.tight_layout()
plt.show()


# =============================================================================
#  5.5) OPTIONAL CHECK: Time‐Domain Plots of Random Injections
#
#  This block will:
#    • draw a small number (e.g. 4) of random (t_true, φ_true)
#    • build the FD “injection”   H_sig(f) = H0(f) · e^{i φ_true} · e^{−2π i f t_true}
#    • whiten it by W2(f) → X2(f)
#    • inverse‐FFT → x2(t): a real time‐series containing exactly the whitened
#      injection shifted to t_true
#    • plot x2(t) vs. t for a ±0.5 s window around t_true
#  so you can visually inspect that the injection sits where you expect.
#
#  Make sure that, when you run the script, these four subplots show “bumps” in
#  the whitened data x2(t) exactly at t≈t_true.  If they do not, something is wrong
#  in the way you’re constructing H_sig or taking the IFFT.
# =============================================================================

import random

# Number of example injections to plot
n_examples = 4

# Pre‐allocate arrays to hold (t_true, φ_true) for each example
t_example = np.random.uniform(0.3, duration - 0.3, size=n_examples)
φ_example = np.random.uniform(0.0, 2.0 * np.pi,     size=n_examples)

# Prepare the time‐axis for plotting:
t_full = np.linspace(0.0, duration, N, endpoint=False)

# Create a figure with n_examples rows (one for each random injection)
plt.figure(figsize=(8, 2.5 * n_examples))

for k in range(n_examples):
    # 1) Grab this example’s coalescence time and phase
    t_true_k = t_example[k]
    φ_true_k = φ_example[k]

    # 2) Build the frequency‐domain injection:
    #    H_sig_k(f) = H0(f) · e^{i φ_true_k} · e^{−2π i f t_true_k}
    phase_shift_k = np.exp(-2j * np.pi * freqs * t_true_k)
    Hsig_k       = H0 * np.exp(1j * φ_true_k) * phase_shift_k

    # 3) Whiten the injection by PSD2’s min‐phase filter:
    #    X2_k(f) = Hsig_k(f) · W2(f)
    #    Then x2_k(t) = IFFT[ X2_k(f) ]
    X2_k = Hsig_k * W2
    x2_k = np.fft.irfft(X2_k, n=N)

    # 4) Now plot a small window (±0.5 s) around t_true_k
    #    Convert t_true_k to a sample index:
    idx_center = int(np.round(t_true_k / dt))

    #    We want ±(0.5 s) → ±(0.5 * fs) samples
    half_window = int(0.5 * fs)

    #    Define the slice limits (clamp to [0, N−1])
    idx_lo = max(0, idx_center - half_window)
    idx_hi = min(N, idx_center + half_window)

    #    Corresponding time‐axis for this slice:
    t_slice = t_full[idx_lo:idx_hi]
    x2_slice = x2_k[idx_lo:idx_hi]

    # 5) Subplot:
    plt.subplot(n_examples, 1, k+1)
    plt.plot(t_slice, x2_slice, 'r-')
    plt.axvline(t_true_k, color='k', linestyle='--', linewidth=1,
                label=f'$t_{{\\rm true}} = {t_true_k:.3f}\\,$s')
    plt.xlabel('Time [s]')
    plt.ylabel('Whitened $x_2(t)$')
    plt.title(f'Example {k+1}: Injection at $t_{{true}}={t_true_k:.3f}\\,$s, $\\phi_{{true}}={φ_true_k:.2f}\\,$rad')
    plt.xlim(t_true_k - 0.5, t_true_k + 0.5)
    plt.legend(loc='upper right', fontsize='small')

plt.tight_layout()
plt.show()
